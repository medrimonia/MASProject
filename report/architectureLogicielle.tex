% Intro, divisions en dossiers
\paragraph{}
Le mélange d'affichage et de systèmes multi-agents se prêtait particulièrement
bien à un minimum d'organisation logicielle. Effectivement, s'il est agréable
de faciliter la lecture par une séparation claire de ces deux composantes, il
y a surtout énormément de factorisation possible avec une architecture
adaptée. Tous les objets graphiques nécessitant d'être placés au niveau du sol
par exemple.

\paragraph{}
S'il n'est pas intéressant de détailler tous les choix d'architectures que
nous avons effectué au cours du projet, il existe tout de même quelques points
que nous souhaitons souligner et expliquer.

\subsection{Arborescence des classes d'objets}
% Ajout diagramme de classe réduit?
\paragraph{}
Avec comme principal objectif la factorisation de code, nous avons passé aux
cribles les différentes entités que nous souhaitions créer. Il y avait des
ogres, des robots et des tonneaux. Nous avons tout d'abord établi une
disctinction entre les objets qui allaient être manipulé et les agents.
Ceux-ci n'ayant très clairement pas le même contrat à remplir. Cependant, ils
partageaient tout de même clairement une propriété, celle d'être des objets
affichables et mobiles, pouvant être perçu par des agents afin qu'ils prennent
des décisions. C'est cette aspect qui nous a amené à la création de la classe
\verb!GraphicalObject! dont héritaient la classe \verb!Stone! et la classe
\verb!GraphicalAgent!,  la seconde regroupant les ogres et les robots.

\paragraph{}
Cette classe encapsulait l'ensemble composé de l'entité et du noeud Mogre
correspondant à un objet affichable. Elle définissait des fonctions permettant
de placer les objets sur le sol\footnote{En plaçant le bas de leur
\verb!BoundingBox! sur le plan définis par les axes X et Z dans le repère
global de la scène} ou de les orienter en direction d'un point donné.
Certaines propriétés telles que l'orientation ou l'orientation de la caméra
ont été définies comme virtuelle à cause de la conception des différents
objets, effectivement si l'orientation d'un ogre était colinéaire à son
déplacement, il se déplaçait en fait sur le côté. Il était donc nécessaire
pour certains objets de redéfinir leur orientation afin qu'elle soit
consistante.

\paragraph{}
Un détail que nous avons introduit plus tard était la notion d'utilisabilité,
cette notion est devenu nécessaire à nos yeux lorsque nous avons cherché à
garder des références vers des agents afin de pouvoir les suivre
\footnote{Avec un spot lumineux ou avec une caméra}. D'autres modules
conservant un lien vers cet agent, il était nécessaire de savoir si l'agent
était mort pour cesser de le suivre. De plus cette modification nous a permis
de conserver les tonneaux dans les objets appartenant au monde, sans risquer
pour autant qu'un agent cherche à s'emparer d'un objet qu'un autre agent s'est
déjà approprié.

\subsection{Gestion des entrées}
% Nombre elevé d'actions possibles
\paragraph{}
La possibilité d'agir sur le monde et de contrôler différents facteurs a été
offerte à l'utilisateur, lui permettant ainsi d'activer ou de désactiver le
brouillard par exemple. Le nombre d'options offertes étant relativement
élevé, nous avons pensé qu'il serait très difficile aussi bien pour
l'utilisateur que pour le développeur de se retrouver dans ce monde si nous
établissions une relation simple entre les commandes, nous avons donc décidé
d'utiliser différents modes, chacun possédant sa propre relation entre les
commandes et les touches utilisées. Nous avons tout de même choisi de partager
certaines commandes entre tous les modes, par exemple le raccourci permettant
de mettre le monde en pause.

\paragraph{}
Afin de pouvoir changer facilement de mode, nous avons utilisé une structure
très simple avec un mode racine auquel on pouvait revenir à tout moment en
pressant la touche \verb!Échap!, les autres modes étaient accessibles depuis
celui-ci via des raccourcis. Afin de pouvoir facilement tester le mode
d'entrée actuel, nous avons aussi créer un enum \verb!InputMode! listant les
différents mode d'entrée.

% CommandHelper + Database
\paragraph{}
Afin que l'utilisateur n'ait pas à aller explorer le code source ou à lire une
notice pour pouvoir comprendre comment accéder aux fonctionnalités désirées,
nous avons écrit une classe \verb!CommandHelper! Permettant de décrire
facilement une commande à l'aide de son raccourci et d'une description de son
effet. Pour conserver et pouvoir afficher ces aides facilement et de manière
appropriée, nous avons aussi écrit une classe \verb!CommandDatabase! qui
encapsulait un dictionnaire faisant correspondre à un \verb!InputMode! donné
la liste des commandes associées. Il permettait aussi d'enregistrer les
commandes accessibles depuis tous les modes et offrait grâce à une fonction
l'accès à toutes les commandes\footnote{globales et spécifiques} disponibles
dans un mode donné.

\subsection{Les overlays}

\subsection{Utilitaires}
